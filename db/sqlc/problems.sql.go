// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: problems.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createProblem = `-- name: CreateProblem :exec

INSERT INTO problems (
    id, title, description, time_limit_ms, memory_limit_mb, difficulty
) VALUES (
    $1, $2, $3, $4, $5, $6
)
`

type CreateProblemParams struct {
	ID            string         `json:"id"`
	Title         string         `json:"title"`
	Description   string         `json:"description"`
	TimeLimitMs   int32          `json:"time_limit_ms"`
	MemoryLimitMb int32          `json:"memory_limit_mb"`
	Difficulty    sql.NullString `json:"difficulty"`
}

// db/queries/problems.sql
func (q *Queries) CreateProblem(ctx context.Context, arg CreateProblemParams) error {
	_, err := q.db.ExecContext(ctx, createProblem,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.TimeLimitMs,
		arg.MemoryLimitMb,
		arg.Difficulty,
	)
	return err
}

const createProblemLanguageHarness = `-- name: CreateProblemLanguageHarness :exec
INSERT INTO problem_language_harnesses (
    problem_id, language, harness_code
) VALUES (
    $1, $2, $3
)
`

type CreateProblemLanguageHarnessParams struct {
	ProblemID   string `json:"problem_id"`
	Language    string `json:"language"`
	HarnessCode string `json:"harness_code"`
}

func (q *Queries) CreateProblemLanguageHarness(ctx context.Context, arg CreateProblemLanguageHarnessParams) error {
	_, err := q.db.ExecContext(ctx, createProblemLanguageHarness, arg.ProblemID, arg.Language, arg.HarnessCode)
	return err
}

const createTestCase = `-- name: CreateTestCase :exec
INSERT INTO test_cases (
    problem_id, input, expected_output, is_hidden
) VALUES (
    $1, $2, $3, $4
)
`

type CreateTestCaseParams struct {
	ProblemID      string `json:"problem_id"`
	Input          string `json:"input"`
	ExpectedOutput string `json:"expected_output"`
	IsHidden       bool   `json:"is_hidden"`
}

func (q *Queries) CreateTestCase(ctx context.Context, arg CreateTestCaseParams) error {
	_, err := q.db.ExecContext(ctx, createTestCase,
		arg.ProblemID,
		arg.Input,
		arg.ExpectedOutput,
		arg.IsHidden,
	)
	return err
}

const deleteProblem = `-- name: DeleteProblem :exec
DELETE FROM problems
WHERE id = $1
`

func (q *Queries) DeleteProblem(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteProblem, id)
	return err
}

const deleteProblemLanguageHarnessesByProblemID = `-- name: DeleteProblemLanguageHarnessesByProblemID :exec
DELETE FROM problem_language_harnesses
WHERE problem_id = $1
`

func (q *Queries) DeleteProblemLanguageHarnessesByProblemID(ctx context.Context, problemID string) error {
	_, err := q.db.ExecContext(ctx, deleteProblemLanguageHarnessesByProblemID, problemID)
	return err
}

const deleteTestCasesByProblemID = `-- name: DeleteTestCasesByProblemID :exec
DELETE FROM test_cases
WHERE problem_id = $1
`

func (q *Queries) DeleteTestCasesByProblemID(ctx context.Context, problemID string) error {
	_, err := q.db.ExecContext(ctx, deleteTestCasesByProblemID, problemID)
	return err
}

const getProblem = `-- name: GetProblem :one
SELECT id, title, description, time_limit_ms, memory_limit_mb, difficulty
FROM problems
WHERE id = $1
`

func (q *Queries) GetProblem(ctx context.Context, id string) (Problem, error) {
	row := q.db.QueryRowContext(ctx, getProblem, id)
	var i Problem
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.TimeLimitMs,
		&i.MemoryLimitMb,
		&i.Difficulty,
	)
	return i, err
}

const getProblemLanguageHarnesses = `-- name: GetProblemLanguageHarnesses :many
SELECT language, harness_code
FROM problem_language_harnesses
WHERE problem_id = $1
`

type GetProblemLanguageHarnessesRow struct {
	Language    string `json:"language"`
	HarnessCode string `json:"harness_code"`
}

func (q *Queries) GetProblemLanguageHarnesses(ctx context.Context, problemID string) ([]GetProblemLanguageHarnessesRow, error) {
	rows, err := q.db.QueryContext(ctx, getProblemLanguageHarnesses, problemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProblemLanguageHarnessesRow{}
	for rows.Next() {
		var i GetProblemLanguageHarnessesRow
		if err := rows.Scan(&i.Language, &i.HarnessCode); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProblemsWithFilter = `-- name: GetProblemsWithFilter :many
SELECT 
    id, 
    title, 
    description, 
    difficulty
FROM problems
WHERE 
    ($1::text IS NULL OR difficulty = $1)
ORDER BY id
LIMIT $2 OFFSET $3
`

type GetProblemsWithFilterParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetProblemsWithFilterRow struct {
	ID          string         `json:"id"`
	Title       string         `json:"title"`
	Description string         `json:"description"`
	Difficulty  sql.NullString `json:"difficulty"`
}

func (q *Queries) GetProblemsWithFilter(ctx context.Context, arg GetProblemsWithFilterParams) ([]GetProblemsWithFilterRow, error) {
	rows, err := q.db.QueryContext(ctx, getProblemsWithFilter, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProblemsWithFilterRow{}
	for rows.Next() {
		var i GetProblemsWithFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Difficulty,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestCases = `-- name: GetTestCases :many
SELECT id, input, expected_output, is_hidden
FROM test_cases
WHERE problem_id = $1
`

type GetTestCasesRow struct {
	ID             int32  `json:"id"`
	Input          string `json:"input"`
	ExpectedOutput string `json:"expected_output"`
	IsHidden       bool   `json:"is_hidden"`
}

func (q *Queries) GetTestCases(ctx context.Context, problemID string) ([]GetTestCasesRow, error) {
	rows, err := q.db.QueryContext(ctx, getTestCases, problemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTestCasesRow{}
	for rows.Next() {
		var i GetTestCasesRow
		if err := rows.Scan(
			&i.ID,
			&i.Input,
			&i.ExpectedOutput,
			&i.IsHidden,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProblem = `-- name: UpdateProblem :exec
UPDATE problems
SET
    title = COALESCE($2, title),
    description = COALESCE($3, description),
    time_limit_ms = COALESCE($4, time_limit_ms),
    memory_limit_mb = COALESCE($5, memory_limit_mb),
    difficulty = COALESCE($6, difficulty)
WHERE id = $1
`

type UpdateProblemParams struct {
	ID            string         `json:"id"`
	Title         string         `json:"title"`
	Description   string         `json:"description"`
	TimeLimitMs   int32          `json:"time_limit_ms"`
	MemoryLimitMb int32          `json:"memory_limit_mb"`
	Difficulty    sql.NullString `json:"difficulty"`
}

func (q *Queries) UpdateProblem(ctx context.Context, arg UpdateProblemParams) error {
	_, err := q.db.ExecContext(ctx, updateProblem,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.TimeLimitMs,
		arg.MemoryLimitMb,
		arg.Difficulty,
	)
	return err
}
